#include<cstdio>
#include<vector>
#include"fast_check.cpp"
#define REP(i,b,e) for(int i=(b);i<(e);i++)

Graph construct0(int n, int d1, int d2) {
    Graph t0(n);
    int diff = d2 - d1, lim = n - d2 + 1;

    REP(i, n-d2+1, n-d1+1) t0.add_edge(i, (i+d2)%n);
    REP(i, n-d1+1, n) t0.add_edge(i, (i+d1)%n);
    REP(i, 0, d1-1) t0.add_edge(i, i+1);

    for(int base = 0; base < n - d2 + 1; base += d2) {
        REP(i, 1, diff+1) if(base+i + d1 < lim) t0.add_edge(base+i, base+i + d1);
        REP(i, 1, d1) if(base+i + d2 < lim) t0.add_edge(base+i, base+i + d2);
        if(base+d1 < lim) t0.add_edge(base+d1 - 1, base+d1);
    }
    return t0;
}

Graph construct1(int n, int d1, int d2) {
    Graph t1(n);
    int diff = d2 - d1, lim = n - d2 + 1;

    REP(i, n-d1+1, n) t1.add_edge(i, (i+d2)%n);
    t1.add_edge(0, d1);
    REP(i, 1, d2-1) t1.add_edge(i, i+1);

    for(int base = 1; base < lim; base += d2) {
        REP(i, diff, d2-1) if(base+i + d1 < lim) t1.add_edge(base+i, base+i + d1);
        REP(i, d1-1, d1-1+diff) if(base+i + d2 < lim) t1.add_edge(base+i, base+i + d2);
        if(base+d2-1 < lim) t1.add_edge(base+d2-1-1, base+d2-1);
    }

    if(diff ==  1 and (n+2)%d2 == 0) t1.add_edge(n-d1 - d2, n-d1);
    else REP(i, n-d2+1, n-d1+1) t1.add_edge(i - ((d1 < i%d2)? d2:d1), i);
    return t1;
}

Graph construct2(int n, int d1, int d2) {
    Graph t2(n);
    int diff = d2 - d1, lim = n - d2 + 1;

    t2.add_edge(0, d2);
    REP(i, 1, d1) t2.add_edge(i, i+d1);
    t2.add_edge(d2-1, d2); 

    for(int base = d1; base < lim; base += d2) {
        if(base+diff + d1 < lim) t2.add_edge(base+diff, base+diff + d1);
        if(base+diff + d2 < lim) t2.add_edge(base+diff, base+diff + d2);
        REP(i, 0, d2-1) if(i!=diff-1 and base+i + 1 < lim) t2.add_edge(base+i, base+i + 1);
    }

    if(diff == 1 and (n+2)%d2 == 0) t2.add_edge(n-d1 - d1, n-d1);
    else REP(i, n-d2+1, n-d1+1) t2.add_edge(i - ((d1 < i%d2)? d1:d2), i);
    REP(i, n-d1+1, n) t2.add_edge(i - d2, i);
    return t2;
}


bool construct_and_check_trees(int n, int d1, int d2, bool verbose = false) {
    if(verbose) printf("(n, d1, d2) = (%d, %d, %d)\n", n, d1, d2);
    Graph t0 = construct0(n, d1, d2);
    Graph t1 = construct1(n, d1, d2);
    Graph t2 = construct2(n, d1, d2);
    Graph t3(n), t4(n), t5(n);
    REP(i, 0, n) REP(j, i+1, n) if(t0.mat[i][j]) t3.add_edge((n-i)%n, n-j);
    REP(i, 0, n) REP(j, i+1, n) if(t1.mat[i][j]) t4.add_edge((n-i)%n, n-j);
    REP(i, 0, n) REP(j, i+1, n) if(t2.mat[i][j]) t5.add_edge((n-i)%n, n-j);
    
    std::vector<Graph> ts = {t0, t1, t2, t3, t4, t5};
    return cr_check(ts, verbose);
}


int main() {
    /*
    bool ok = true;
    REP(diff, 1, 60) {
        REP(n, 5*diff+3, 300) { //[5diff+3, infty)
            printf("n = %2d\n", n);
            REP(d1, diff+1, (n+3-2*diff)/3) { //[1+diff, (n+1-2*diff)/3)
                int d2 = d1 + diff;
                printf("  CR(%2d,%2d,%2d)", n, d1, d2); fflush(stdout);
                if(!construct_and_check_trees(n, d1, d2)) ok = false;
                else printf(" ... OK :)"); puts("");
            }
        }
    }
    if(ok) printf("1 <= diff < 60, 5*diff+2 < n < 300, \n\t 1+diff <= d1 < (n+1-2*diff)/3, d2 = d1 + diff ... OK\n");
    else printf("NG\n");
    //*/

    /*
    bool ok = true;
    REP(n, 1, 256) {
        REP(d1, 2, n/2) {
            REP(d2, d1+1, std::min(2*d1, (n-d1+2)/2)) { //[d1+1, min{2*d1, (n-d1+1)/2})
                printf("  CR(%3d,%3d,%3d)", n, d1, d2); fflush(stdout);
                if(!construct_and_check_trees(n, d1, d2)) ok = false;
                else printf(" ... OK :)"); puts("");
            }
        }
    }
    if(ok) puts("N < 256, 2 <= d1 < d2 < min(2*d1, (N+1-d1)/2) ... OK");
    else puts("NG");
    //*/

    int n, d1, d2;
    //printf(" n >> "); scanf("%d", &n);
    //printf("d1 >> "); scanf("%d", &d1);
    //printf("d2 >> "); scanf("%d", &d2);
    construct_and_check_trees(28, 6, 11, true);
    return 0;
}
